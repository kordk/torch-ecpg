import math
import random
from typing import Any, Callable, Dict, List, Optional, Tuple

import pandas


def randrange(
    start: float,
    end: float,
    integer: bool = False,
) -> Callable[[], int | float]:
    """
    Returns a callable that generates a random float between start
    and end or an int if integer is True (default False).
    """

    def func(*_) -> int | float:
        if integer:
            return math.floor(random.random() * (end + 1 - start) + start)
        else:
            return random.random() * (end - start) + start

    return func


def generate_codes(
    num: int, prefix: str = '', suffix: str = '', start: int = 1
) -> List[str]:
    """
    Returns a list of num strings in ascending order, formatted with
    a prefix, suffix, and padded with up to two zeros. Start indicates
    the start index, default 1.
    """
    out = []
    for i in range(start, num + start):
        out.append(prefix + f'{i:03d}' + suffix)
    return out


def generate_dataframe(
    column_names: List[str], row_names: List[str], value_gen: Callable[[], Any]
) -> pandas.DataFrame:
    """
    Generates a pandas dataframe with columns dictated by column_names
    and rows dictated by row_names. The values in this dataframe are
    generated by calling value_gen, which returns any value.
    """
    n = len(row_names)
    data = {column: [value_gen() for _ in range(n)] for column in column_names}
    return pandas.DataFrame(
        data,
        row_names,
    )


def generate_from_template(
    row_names: List[str],
    template: Dict[str, Callable[[], Any]],
    annotation: bool = False,
) -> pandas.DataFrame:
    """
    Generates the templated dataframe given the row_names, a list of
    person ids, and covariate_template. The template is a dictionary
    that maps a characteristic to any value. The function returns the
    templated dataframe.
    """
    n = len(row_names)
    if annotation:
        data = {
            column: [value_gen(i) for i in range(n)]
            for column, value_gen in template.items()
        }
        return pandas.DataFrame(data)
    else:
        data = {
            column: [value_gen() for _ in range(n)]
            for column, value_gen in template.items()
        }
        return pandas.DataFrame(data, row_names)


def generate_data(
    sample_size: int,
    m_rows: int,
    g_rows: int,
    annotation: bool = False,
) -> Tuple[pandas.DataFrame, pandas.DataFrame, pandas.DataFrame] | Tuple[
    pandas.DataFrame,
    pandas.DataFrame,
    pandas.DataFrame,
    pandas.DataFrame,
    pandas.DataFrame,
]:
    """
    Generates two pandas dataframes for methylation and gene expression.
    Accepts a sample_size for the number of people, m_rows for the
    number of methylation loci, and g_rows for the number of gene
    expression loci. Returns a tuple of the methylation and gene
    expression dataframes.
    """
    person_codes = generate_codes(sample_size)
    m_row_codes = generate_codes(m_rows, 'cg')
    g_row_codes = generate_codes(g_rows, 'ILMN_')

    M = generate_dataframe(person_codes, m_row_codes, randrange(0, 1))
    G = generate_dataframe(person_codes, g_row_codes, randrange(-1, 100))

    covariate_template = {
        'age': randrange(18, 64),
        'sex': randrange(0, 1, True),
    }
    C = generate_from_template(person_codes, covariate_template)

    if not annotation:
        return M, G, C

    def annotation_template(codes: List[str]) -> Dict[str, Any]:
        return {
            'chrom': randrange(1, 23, True),
            'chromStart': randrange(1, 150_000_000, True),
            'chromEnd': randrange(1, 150_000_000, True),
            'name': lambda x: codes[x],
            'score': lambda _: 0,
            'strand': lambda _: '+' if round(random.random()) else '-',
        }

    M_annot = generate_from_template(
        m_row_codes, annotation_template(m_row_codes), True
    )
    G_annot = generate_from_template(
        g_row_codes, annotation_template(g_row_codes), True
    )

    return M, G, C, M_annot, G_annot
